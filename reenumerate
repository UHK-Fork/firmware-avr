#!/usr/bin/env node

var usb = require('usb');
var argv = require('minimist')(process.argv.slice(2), {boolean:['w', 'wait']});
var async = require('async');

// Global constants and variables

var vendorId = 0x16D1;  // TODO: Restore to 0x16D0 for the final prototype.
var productIds = [0x05EA, 0x05EB, 0x05EC, 0x05ED];

var enumerationModes = {
    'keyboard'         : 0,
    'bootloader-right' : 1,
    'bootloader-left'  : 2
};

var INITIAL_POLLING_INTERVAL = 1500;  // ms
var POLLING_INTERVAL         = 100;   // ms
var MAX_POLLING_DELAY        = 5000;  // ms

var totalWaitDelay = 0;

// Program starts

if (argv._.length != 1) {
    printUsageAndExit();
}

var enumerationMode = enumerationModes[argv._[0]];
var wait = argv.w || argv.wait

if (enumerationMode === undefined) {
    printUsageAndExit();
}

device = findDevice();
device.open();

if (!device) {
    console.log('Keyboard not found');
    process.exit(2);
}

var pollingIntervalId;
async.waterfall([
    function(callback) {
        device.getStringDescriptor(device.deviceDescriptor.iProduct, function(error, productString) {
            callback(error, productString);
        });
    },
    function(productString, callback) {
        console.log('Keyboard found enumerated as "' + productString + '"');

        interfaceNumber = 0;
        interface = device.interface(interfaceNumber);
        if (interface.isKernelDriverActive()) {
            interface.detachKernelDriver();
        }
        interface.claim();

        console.log('Reenumerating keyboard...');
        sendReenumerateCommand(enumerationMode, function(error, data) {
            callback(error, data);
        });
    },
    function(data, callback) {
        if (wait) {
            setTimeout(function() {
                pollingIntervalId = setInterval(waitUntilReenumerate, POLLING_INTERVAL);
                callback(null);
            }, INITIAL_POLLING_INTERVAL);
        } else {
            callback(null);
        }
    }
], function(error, result) {
    if (error) {
        console.log(error);
    }
});

function waitUntilReenumerate()
{
    if (device = findDevice()) {
        async.waterfall([
            function(callback) {
                device.open();
                clearInterval(pollingIntervalId);
                device.getStringDescriptor(device.deviceDescriptor.iProduct, function(error, productString) {
                    callback(error, productString);
                });
            },
            function(productString, callback) {
                console.log('Keyboard reenumerated as "' + productString + '"');
                callback(null);
            }
        ],
        function(error, result) {
            if (error) {
                console.log(error);
            }
        });
    } else if (totalWaitDelay > MAX_POLLING_DELAY) {
        clearInterval(pollingIntervalId);
        console.log('Reenumeration failed');
        process.exit(1);
    }
    totalWaitDelay += POLLING_INTERVAL;
}

// Function definitions

function printUsageAndExit()
{
    console.log('Usage: reenumerate [ -w | --wait ]  { keyboard | bootloader-left | bootloader-right }');
    process.exit(1);
}

function findDevice()
{
    var device = null;
    for (var i=0; i<productIds.length && !device; i++) {
        device = usb.findByIds(vendorId, productIds[i]);
    }
    return device;
}

function sendReenumerateCommand(enumerationMode, callback)
{
    var AGENT_COMMAND_REENUMERATE = 0;
    sendAgentCommand(AGENT_COMMAND_REENUMERATE, enumerationMode, callback);
}

function sendAgentCommand(command, arg, callback)
{
    setReport(new Buffer([command, arg]), callback);
}

function setReport(message, callback)
{
    device.controlTransfer(
        0x21,             // bmRequestType (constant for this control request)
        0x09,             // bmRequest (constant for this control request)
        0,                // wValue (MSB is report type, LSB is report number)
        interfaceNumber,  // wIndex (interface number)
        message,          // message to be sent
        callback
    );
}
